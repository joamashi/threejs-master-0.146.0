"원소 여러 개를 모아놓은 객체"
// 데이터를 저장/조직하는 더욱 개선된 다수의 콜렉션 객체가 새로 추가

"배열 버퍼"
// 배열은 문자열, 숫자, 객체 등 어떤 타입의 원소라도 담을 수 있고 동적으로 계속 커질 수 있는 반면, 
// 실행 시간이 느려지고 메모리 점유율이 높아진다는 점이 문제.
// 계산량이 많고 대량 데이터가 오가는 애플리케이션이라면 큰 이슈가 될 수 있다.
// 이런 이유로 배열 버퍼.array buffer가 등장.

// 배열 버퍼는 메모리 상의 8비트 블록 콜렉션이고 블록 하나가 배열 버퍼의 원소다.
// 배열 버퍼의 크기는 생성 시 결정되므로 동적으로 커지지 않으며, 숫자만 저장할 수 있고 처음에 모든 블록이 0으로 초기화된다.


let buffer = new ArrayBuffer(80); // 80 바이트 크기

// 배열 버퍼 객체와 데이터 읽기/쓰기는 DataView 객체의 몫이다.
// 숫자를 꼭 8비트로만 나타내야 하는 건 아니고 8, 16, 32, 64비트도 가능

let buffer = new ArrayBuffer(80);
let view = new DataView(buffer);

view.setInt32(8,22,false);

var number = view.getInt32(8, false); // 22


"타입화 배열"
// 배열 버퍼에서 숫자를 읽기/쓰기하는 방법을 배웠는데, 매번 이렇게 함수를 호출하는 건 상당히 귀찮다.
// 타입화 배열은 마치 일반 배열을 다루는 것처럼 배열 버퍼 객체에 읽기/쓰기할 수 있다.

var buffer = new ArrayBuffer(80);
var typed_array = new Float64Array(buffer);
typed_array[4] = 11;

typed_array.length  // 10
typed_array[4]      // 11


"세트"
// 타입에 상관없이 ‘’유일한’ 값을 담은 콜렉션으로 원소들은 삽입한 순서대로 정렬

let set1 = new Set();
let set2 = new Set('안녕하세요!!!');

let set = new Set('안녕하세요!!!');
set.add(12);    // 12를 추가
set.has('!');  // 값이 존재하는지 확인
set.size;
set.delete(12); // 12를 삭제
...set
set.clear();    // 모든 값을 삭제


"위크세트"
// 세트는 원시 타입과 객체 참조값 모두를 담을 수 있지만, 위크세트는 객체 참조값만 저장
// 내부에 저장된 참조하는 값이 없을 땐 가비지 콜렉션 대상이 된다
// 위크세트 객체는 열거할 수 없어서 크기를 알 수 없고 이터러블 규약을 따르지 않는다.


"맵"
// 키/값 쌍을 모아놓은 콜랙션. 키/값의 타입은 제약이 없다.

let map = new Map();
let o = {n:1};

map.set(o, 'A'); // 추가
map.set('2', 9);

map.has('2'); // 값이 존재하는지 확인
map.get(o);  // 키의 해당 값 조회
...map

map.delete('2'); // 키/값 삭제
map.clear();    // 전부 삭제


// 이터러블 객체로부터 맵 생성
let map_1 = new Map([[1,2], [4,5]]);
map_1.size; // 2


"위크맵"
// 맵의 키는 원시 타입, 객체 참조값 모두 가능하지만 위크맵 키는 오직 객체 참조값만 가능
// 내부에 저장된 객체를 참조하는 값이 없을 경우 가비지 콜렉션 대상이 된다
// 위크맵 객체는 열거할 수 없어서 크기를 알 수 없고 이터러블 규약을 따르지 않는다.